////////////////////////////////////////////////////////////////////////////////
// Filename: Texture.ps
////////////////////////////////////////////////////////////////////////////////

/////////////
// GLOBALS //
/////////////
cbuffer TextureBuffer
{
	float w1;
	float w2;
	float w3;
	float o1;
	float o2;
	float o3;
	float2 spread;
	float2 tilesize;
	float norm;
	float padding;
};


Texture2D Texture;
SamplerState SampleType;


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	float2 sum = float2(0.0, 0.0);

	float2 s = spread * tilesize;

	float2 tex_m1 = input.tex - o3 * s;
	float2 tex_m2 = input.tex - o2 * s;
	float2 tex_m3 = input.tex - o1 * s;

	float2 tex_p1 = input.tex + o1 * s;
	float2 tex_p2 = input.tex + o2 * s;
	float2 tex_p3 = input.tex + o3 * s;

	sum += Texture.Sample(SampleType, input.tex).ra;
	sum += w1 * (Texture.Sample(SampleType, tex_m1).ra + Texture.Sample(SampleType, tex_p1).ra);
	sum += w2 * (Texture.Sample(SampleType, tex_m2).ra + Texture.Sample(SampleType, tex_p2).ra);
	sum += w3 * (Texture.Sample(SampleType, tex_m3).ra + Texture.Sample(SampleType, tex_p3).ra);
	sum /= norm;

	return float4(sum.x, sum.x, sum.x, sum.y);
}
