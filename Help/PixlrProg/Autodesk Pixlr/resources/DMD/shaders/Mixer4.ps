////////////////////////////////////////////////////////////////////////////////
// Filename: Texture.ps
////////////////////////////////////////////////////////////////////////////////

/////////////
// GLOBALS //
/////////////
cbuffer TextureBuffer
{
	float scale_width;
	float scale_height;
	float image_brightness;
	float pattern_brightness;
	float pattern_rotation;
	float3 padding;
};


Texture2D Texture1;
Texture2D Texture2;
SamplerState SampleType;


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	float2 center = float2(0.5, 0.5);
	float2x2 rotation = float2x2(cos(pattern_rotation), sin(pattern_rotation),
								 -sin(pattern_rotation), cos(pattern_rotation));
	float2 rotatedTex = mul(rotation, input.tex - center) + center;
	
	float4 c = Texture1.Sample(SampleType, input.tex);

	// Add the rotation transform
	float2 pcoord = float2(frac(rotatedTex.x * scale_width), frac(rotatedTex.y * scale_height));

	float p = pattern_brightness * Texture2.Sample(SampleType, pcoord).x;
	float cb = image_brightness * dot(c.rgb, float3(0.299, 0.587, 0.114));

	float eps = 0.0000001;
	float ob = pow(p, (1.0 + eps - cb)/(cb + eps));
	return float4(float3(ob, ob, ob) * c.a, c.a);
}
