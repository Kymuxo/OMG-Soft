////////////////////////////////////////////////////////////////////////////////
// Filename: Texture.ps
////////////////////////////////////////////////////////////////////////////////

/////////////
// GLOBALS //
/////////////
cbuffer TextureBuffer
{
	float2 tile_offset;  // offset in texture space
	float2 tile_scale;   // ratio of texture/tile
	float threshold;
	float strength;
	float swirl;
	float padding;
};


Texture2D Texture1;
Texture2D Texture2;
SamplerState SampleType;


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};

// This maps texcoords meant for a tile of the primary image into texcoords we can use to map into 
// the repeating pattern.  It shouldn't change anything for two textures of the same size.
float2 PatternToTile(float2 texCoord)
{
	float2 tc = texCoord * tile_scale - tile_offset;
	return frac(tc);
}

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	// Have to map from the texture to the area inside the texture that we're trying to process.
	float2 tex = PatternToTile(input.tex);
	
	float4 c = Texture1.Sample(SampleType, input.tex);
	if(c.a != 0.0)
	{
		c.rgb /= c.a;
	}
	float2 coord = PatternToTile(input.tex);
	coord += swirl * c.xy; 
	coord = float2(frac(coord.x), frac(coord.y));
	float3 t = Texture2.Sample(SampleType, coord).xxx;
	t = strength*(float3(threshold, threshold, threshold) - t); 
	float3 oc = clamp(c.rgb + t, float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0));  
	oc.rgb *= c.a;

	return float4(oc, c.a);
}
